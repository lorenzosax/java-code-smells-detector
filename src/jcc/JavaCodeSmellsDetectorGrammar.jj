/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. JavaCodeSmellsDetectorGrammar.jj */
/*@egen*//**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */options{  static = true;}PARSER_BEGIN(JavaCodeSmellsDetector)
package jcc;

import java.io.*;
import java.util.*;

public class JavaCodeSmellsDetector/*@bgen(jjtree)*/implements JavaCodeSmellsDetectorTreeConstants/*@egen*/{/*@bgen(jjtree)*/
  protected static JJTJavaCodeSmellsDetectorState jjtree = new JJTJavaCodeSmellsDetectorState();

/*@egen*/  public static void main(String args []) throws ParseException, IOException  {
    try
    {
      FileInputStream file = new FileInputStream("Process.java");
      
      JavaCodeSmellsDetector detector = new JavaCodeSmellsDetector(file);
      SimpleNode sn = detector.compilationUnit();
      sn.dump("");
	}
    catch (Exception e)
    {
      System.out.println("Oops.");
      System.out.println(e.getMessage());
    }

    /*JavaCodeSmellsDetectorTokenManager jcsd;
	Token t;
	SimpleCharStream scs = new SimpleCharStream(new FileInputStream("Process.java"));

	jcsd = new JavaCodeSmellsDetectorTokenManager(scs);
	t = jcsd.getNextToken();

	while(t.kind != JavaCodeSmellsDetectorConstants.EOF) {
		System.out.println(t.kind + ": " + t.image);
		t = jcsd.getNextToken();
	}*/
	  }}PARSER_END(JavaCodeSmellsDetector)
TOKEN_MGR_DECLS :
{}

SKIP :
{
  <SPACE: [" ", "\t", "\f"]>
| <WINDOWS_EOL : "\r\n">
| <UNIX_EOL: "\n">
| <OLD_MAC_EOL: "\r">
| < "//" > : IN_COMMENTO_SINGLE_LINE
| < "/*" > : IN_COMMENTO_MULTI_LINE
| < "@" < ID >> : ANNOTATION
}

< IN_COMMENTO_SINGLE_LINE >
SKIP :
{
  < "\n" | "\r\n" > : DEFAULT
| < ~[ ] >
}

< IN_COMMENTO_MULTI_LINE >
SKIP :
{
  < "*/" > : DEFAULT
| < ~[ ] >
}

< ANNOTATION >
SKIP :
{
  < "\n" | "\r\n" > : DEFAULT
| < ~[ ] >
}

/* RESERVED WORDS*/

TOKEN :
{
  < ABSTRACT: "abstract" >
| < ASSERT: "assert" >
| < BOOLEAN: "boolean" >
| < BREAK: "break" >
| < BYTE: "byte" >
| < CASE: "case" >
| < CATCH: "catch" >
| < CHAR: "char" >
| < CLASS: "class" >
| < CONST: "const" >
| < CONTINUE: "continue" >
| < _DEFAULT: "default" >
| < DO: "do" >
| < DOUBLE: "double" >
| < ELSE: "else" >
| < ENUM: "enum" >
| < EXTENDS: "extends" >
| < FALSE: "false" >
| < FINAL: "final" >
| < FINALLY: "finally" >
| < FLOAT: "float" >
| < FOR: "for" >
| < GOTO: "goto" >
| < IF: "if" >
| < IMPLEMENTS: "implements" >
| < IMPORT: "import" >
| < INSTANCEOF: "instanceof" >
| < INT: "int" >
| < INTERFACE: "interface" >
| < LONG: "long" >
| < NATIVE: "native" >
| < NEW: "new" >
| < NULL: "null" >
| < PACKAGE: "package">
| < PRIVATE: "private" >
| < PROTECTED: "protected" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < SHORT: "short" >
| < STATIC: "static" >
| < STRICTFP: "strictfp" >
| < SUPER: "super" >
| < SWITCH: "switch" >
| < SYNCHRONIZED: "synchronized" >
| < THIS: "this" >
| < THROW: "throw" >
| < THROWS: "throws" >
| < TRANSIENT: "transient" >
| < TRUE: "true" >
| < TRY: "try" >
| < VOID: "void" >
| < VOLATILE: "volatile" >
| < WHILE: "while" >
//| < YIELD: "yield" > {if(!yieldSupported)matchedToken.kind=IDENTIFIER;}
| < REQUIRES: "requires" >
| < TO: "to" >
| < WITH: "with" >
| < OPEN: "open" >
| < OPENS: "opens" >
| < USES: "uses" >
| < MODULE: "module" >
| < EXPORTS: "exports" >
| < PROVIDES: "provides" >
| < TRANSITIVE: "transitive" >
}

TOKEN : /* NUMBERS */
{
  < #DIGIT : [ "0"-"9" ] >
| < #DIGITS : (< DIGIT >)+ >
| < #OPT_FRANCTION : ("." < DIGITS >)? >
| < #OPT_EXPONENT :
    (
      "E" ([ "+", "-" ])? < DIGITS >
    )? >
| < NUM :
    (
      "+"
    | "-"
    )?
    < DIGITS > < OPT_FRANCTION > < OPT_EXPONENT > >
}

TOKEN :
{
	< LITERAL : "\"" (~["\n","\r"])* "\"" >
}

TOKEN : /* IDENTIFIERS*/
{
  < ID :
    [ "A"-"Z", "a"-"z", "_" ]
    (
      [ "A"-"Z", "a"-"z", "_" ]
    | < DIGIT >
    )* >
}

TOKEN : /* PUNCTUATION SIMBOLS */
{
  < PARTA : "(" >
| < PARTC : ")" >
| < PARQA : "[" >
| < PARQC : "]" >
| < PARGA : "{" >
| < PARGC : "}" >
| < SEMIC : ";" >
| < COMMA : "," >
| < DOT : "." >
}

SimpleNode compilationUnit() :
{/*@bgen(jjtree) compilationUnit */
  SimpleNode jjtn000 = new SimpleNode(JJTCOMPILATIONUNIT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) compilationUnit */
        try {
/*@egen*/
	(packageDeclaration())? (importDeclarations())? (typeDeclarations())?/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
	  return jjtn000;
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void packageDeclaration() :
{/*@bgen(jjtree) packageDeclaration */
  SimpleNode jjtn000 = new SimpleNode(JJTPACKAGEDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) packageDeclaration */
  try {
/*@egen*/
  < PACKAGE > packageName() < SEMIC >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void packageName() :
{/*@bgen(jjtree) packageName */
  SimpleNode jjtn000 = new SimpleNode(JJTPACKAGENAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) packageName */
  try {
/*@egen*/
  < ID > packageName1()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void packageName1() :
{/*@bgen(jjtree) packageName1 */
  SimpleNode jjtn000 = new SimpleNode(JJTPACKAGENAME1);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) packageName1 */
  try {
/*@egen*/
  "." < ID > packageName1() |/*@bgen(jjtree)*/
                              {
                                jjtree.closeNodeScope(jjtn000, true);
                                jjtc000 = false;
                              }
/*@egen*/ {}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void importDeclarations() :
{/*@bgen(jjtree) importDeclarations */
  SimpleNode jjtn000 = new SimpleNode(JJTIMPORTDECLARATIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) importDeclarations */
  try {
/*@egen*/
  importDeclaration()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ //| importDeclarations() importDeclaration()
}

void importDeclaration() :
{/*@bgen(jjtree) importDeclaration */
  SimpleNode jjtn000 = new SimpleNode(JJTIMPORTDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) importDeclaration */
  try {
/*@egen*/
  singleTypeImportDeclaration() | typeImportOnDemandDeclaration()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void singleTypeImportDeclaration() :
{/*@bgen(jjtree) singleTypeImportDeclaration */
  SimpleNode jjtn000 = new SimpleNode(JJTSINGLETYPEIMPORTDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) singleTypeImportDeclaration */
  try {
/*@egen*/
  < IMPORT > /*typeName()*/ < SEMIC >/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void typeImportOnDemandDeclaration() :
{/*@bgen(jjtree) typeImportOnDemandDeclaration */
  SimpleNode jjtn000 = new SimpleNode(JJTTYPEIMPORTONDEMANDDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) typeImportOnDemandDeclaration */
  try {
/*@egen*/
  < IMPORT > "." < SEMIC >/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void typeDeclarations() :
{/*@bgen(jjtree) typeDeclarations */
  SimpleNode jjtn000 = new SimpleNode(JJTTYPEDECLARATIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) typeDeclarations */
 try {
/*@egen*/
 < ID >/*@bgen(jjtree)*/
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}