/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options
{
  static = true;
}

PARSER_BEGIN(JavaCodeSmellsDetector)

package jcc;

import java.io.*;
import java.util.*;

public class JavaCodeSmellsDetector
{
  public static void main(String args []) throws ParseException, IOException
  {
    try
    {
      FileInputStream file = new FileInputStream("Example.java");
      
      JavaCodeSmellsDetector detector = new JavaCodeSmellsDetector(file);
      SimpleNode sn = detector.compilationUnit();
      sn.dump("");
	}
    catch (Exception e)
    {
      System.out.println("Oops.");
      System.out.println(e.getMessage());
    }

    /*JavaCodeSmellsDetectorTokenManager jcsd;
	Token t;
	SimpleCharStream scs = new SimpleCharStream(new FileInputStream("Process.java"));

	jcsd = new JavaCodeSmellsDetectorTokenManager(scs);
	t = jcsd.getNextToken();

	while(t.kind != JavaCodeSmellsDetectorConstants.EOF) {
		System.out.println(t.kind + ": " + t.image);
		t = jcsd.getNextToken();
	}*/
	
  }
}

PARSER_END(JavaCodeSmellsDetector)

TOKEN_MGR_DECLS :
{}

SKIP :
{
  <SPACE: [" ", "\t", "\f"]>
| <WINDOWS_EOL : "\r\n">
| <UNIX_EOL: "\n">
| <OLD_MAC_EOL: "\r">
| < "//" > : IN_COMMENTO_SINGLE_LINE
| < "/*" > : IN_COMMENTO_MULTI_LINE
| < "@" < ID >> : ANNOTATION
}

< IN_COMMENTO_SINGLE_LINE >
SKIP :
{
  < "\n" | "\r\n" > : DEFAULT
| < ~[ ] >
}

< IN_COMMENTO_MULTI_LINE >
SKIP :
{
  < "*/" > : DEFAULT
| < ~[ ] >
}

< ANNOTATION >
SKIP :
{
  < "\n" | "\r\n" > : DEFAULT
| < ~[ ] >
}

/* RESERVED WORDS*/

TOKEN :
{
  < ABSTRACT: "abstract" >
| < ASSERT: "assert" >
| < BOOLEAN: "boolean" >
| < BREAK: "break" >
| < BYTE: "byte" >
| < CASE: "case" >
| < CATCH: "catch" >
| < CHAR: "char" >
| < CLASS: "class" >
| < CONST: "const" >
| < CONTINUE: "continue" >
| < _DEFAULT: "default" >
| < DO: "do" >
| < DOUBLE: "double" >
| < ELSE: "else" >
| < ENUM: "enum" >
| < EXTENDS: "extends" >
| < FALSE: "false" >
| < FINAL: "final" >
| < FINALLY: "finally" >
| < FLOAT: "float" >
| < FOR: "for" >
| < GOTO: "goto" >
| < IF: "if" >
| < IMPLEMENTS: "implements" >
| < IMPORT: "import" >
| < INSTANCEOF: "instanceof" >
| < INT: "int" >
| < INTERFACE: "interface" >
| < LONG: "long" >
| < NATIVE: "native" >
| < NEW: "new" >
| < NULL: "null" >
| < PACKAGE: "package">
| < PRIVATE: "private" >
| < PROTECTED: "protected" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < SHORT: "short" >
| < STATIC: "static" >
| < STRICTFP: "strictfp" >
| < SUPER: "super" >
| < SWITCH: "switch" >
| < SYNCHRONIZED: "synchronized" >
| < THIS: "this" >
| < THROW: "throw" >
| < THROWS: "throws" >
| < TRANSIENT: "transient" >
| < TRUE: "true" >
| < TRY: "try" >
| < VOID: "void" >
| < VOLATILE: "volatile" >
| < WHILE: "while" >
| < REQUIRES: "requires" >
| < TO: "to" >
| < WITH: "with" >
| < OPEN: "open" >
| < OPENS: "opens" >
| < USES: "uses" >
| < MODULE: "module" >
| < EXPORTS: "exports" >
| < PROVIDES: "provides" >
| < TRANSITIVE: "transitive" >
}

TOKEN : /* NUMBERS */
{
  < #DIGIT : [ "0"-"9" ] >
| < #DIGITS : (< DIGIT >)+ >
| < #OPT_FRANCTION : ("." < DIGITS >)? >
| < #OPT_EXPONENT :
    (
      "E" ([ "+", "-" ])? < DIGITS >
    )? >
| < NUM :
    (
      "+"
    | "-"
    )?
    < DIGITS > < OPT_FRANCTION > < OPT_EXPONENT > >
}


TOKEN : /* IDS*/
{
  < ID :
    [ "A"-"Z", "a"-"z", "_" ]
    (
      [ "A"-"Z", "a"-"z", "_" ]
    | < DIGIT >
    )* >
}

TOKEN: /* OPERATORS*/
{
 
 < ARITOP_LP :
    (
      "+"
    | "-"
    ) >
| < ARITOP_HP :
    (
      "*"
    | "/"
    | "%"
    ) >
}

TOKEN : /* PUNCTUATION SIMBOLS */
{
  < PARTA : "(" >
| < PARTC : ")" >
| < PARQA : "[" >
| < PARQC : "]" >
| < PARGA : "{" >
| < PARGC : "}" >
| < DOT : "." >
| < SEMIC : ";" >
| < COMMA : "," >
}

TOKEN :
{
  < QMARK : "?" >
  | < DPOINTS: ":" >
  | < EXP: [ "^" ] >
  | < ASS : "=" >
  | < MULASS : "*=" >
  | < DIVASS : "/=" >
  | < ADDASS : "+=" >
  | < SUBASS : "-=" >
  | < NOT : "!" >
  | < AND : "&&" >
  | < OR : "||" >
  | < MAJOR : ">" >
  | < MINOR : "<" >
  | < RELOP :
    (
      "<="
    | "=="
    | "!="
    | ">="
    ) >
}

TOKEN :
{
	< LITERAL : "\"" (~["\n","\r"])* "\"" >
	| < CHARVALUE : "\'" (~[ "\n", "\r" ]) "\'" >
}

SimpleNode compilationUnit() :
{}
{
	(packageDeclaration())? (importDeclarations())? (typeDeclarations())? < EOF >
	{
	  return jjtThis;
	}
}

void packageDeclaration() :
{}
{
  < PACKAGE > packageName() < SEMIC >
}

void packageName() :
{}
{
  <ID> packageName1()
}

void packageName1() :
{}
{
  <DOT> (<ID> | < ARITOP_HP >) packageName1() | {}
}

void importDeclarations() :
{}
{
  importDeclaration() importDeclarations1()
}

void importDeclarations1() :
{}
{
  importDeclaration() importDeclarations1() | {}
}

void importDeclaration() :
{}
{
  <IMPORT> packageName() < SEMIC >
}

void superConstruct():
{}
{
  < EXTENDS > classOrInterfaceType()
}

void interfaces():
{}
{
  < IMPLEMENTS > interfaceTypeList()
}

void interfaceTypeList() :
{}
{
  classOrInterfaceType() interfaceTypeList1()
}

void interfaceTypeList1() :
{}
{
  < COMMA > classOrInterfaceType() interfaceTypeList1() | {}
}

void typeDeclarations() :
{}
{
  typeDeclaration() typeDeclarations1() 
}

void typeDeclarations1() :
{}
{
  typeDeclaration() typeDeclarations1() | { }
}

void typeDeclaration() :
{}
{
  LOOKAHEAD(3) classDeclaration() | interfaceDeclaration() | < SEMIC >
}

void classDeclaration() :
{}
{
  (classModifiers())? < CLASS > < ID > (superConstruct())? (interfaces())? classBody()
}

void classModifiers() :
{}
{
  classModifier() classModifiers1()
}

void classModifiers1() :
{}
{
  classModifier() classModifiers1() | {}
}

void classModifier() :
{}
{
  < PUBLIC > | < ABSTRACT > | < FINAL >
}

void classBody() :
{}
{
  < PARGA > (classBodyDeclarations())? < PARGC >
}

void classBodyDeclarations() :
{}
{
   classBodyDeclaration() classBodyDeclarations1()  
}

void classBodyDeclarations1() :
{}
{
  classBodyDeclaration() classBodyDeclarations1() | {}
}

void classBodyDeclaration() :
{}
{
  LOOKAHEAD(4) constructorDeclaration() | LOOKAHEAD(4) classMemberDeclaration() | staticInitializer()
}

void classMemberDeclaration() :
{}
{
  LOOKAHEAD(7) fieldDeclaration() | methodDeclaration()
}

void staticInitializer() :
{}
{
  < STATIC > block()
}

void constructorDeclaration() :
{}
{
  (constructorModifier())? constructorDeclarator() (throwsConstruct())? constructorBody()
}

void constructorModifier() :
{}
{
  < PUBLIC > | < PROTECTED > | < PRIVATE >
}

void constructorDeclarator():
{}
{
  simpleTypeName() < PARTA > (formalParameterList())? < PARTC >
}

void formalParameterList() :
{}
{
  formalParameter() formalParameterList1()
}

void formalParameterList1() :
{}
{
  < COMMA > formalParameter() formalParameterList1() | {}
}

void formalParameter() :
{}
{
  type() variableDeclaratorId()
}

void throwsConstruct() :
{}
{
  < THROWS > classTypeList()
}

void classTypeList() :
{}
{
  classOrInterfaceType() classTypeList1()
}

void classTypeList1() :
{}
{
  < COMMA > classOrInterfaceType() classTypeList1() | {}
}

void constructorBody() :
{}
{
  /*< PARGA > (explicitConstructorInvocation())? (blockStatements())? < PARGC >*/
  LOOKAHEAD(2) < PARGA > < PARGC >
  | LOOKAHEAD(3) {System.out.println("seconda reg");} < PARGA > explicitConstructorInvocation() < PARGC >
  | LOOKAHEAD(3) {System.out.println("consBody block");} < PARGA > blockStatements() < PARGC >
  | < PARGA > explicitConstructorInvocation() blockStatements() < PARGC >
}

void explicitConstructorInvocation() :
{}
{
  < THIS > < PARTA > (argumentList())? < PARTC > | < SUPER > < PARTA > (argumentList())? < PARTC >
}

void fieldDeclaration() :
{}
{
  (fieldModifiers())? type() variableDeclarators() < SEMIC >
}

void fieldModifiers() :
{}
{
  fieldModifier() fieldModifiers1()
}

void fieldModifiers1() :
{}
{
  fieldModifier() fieldModifiers1() | {}
}

void fieldModifier() :
{}
{
  < PUBLIC > | < PROTECTED > | < PRIVATE > | < STATIC > | < FINAL > | < TRANSIENT > | < VOLATILE >
}

void variableDeclarators() :
{}
{
  variableDeclarator() variableDeclarators1()
}

void variableDeclarators1() :
{}
{
  < COMMA > variableDeclarator() variableDeclarators1() | {}
}

void variableDeclarator() :
{}
{
  LOOKAHEAD(7) variableDeclaratorId() < ASS > variableInitializer()
  | variableDeclaratorId()
}

void variableDeclaratorId() :
{}
{
  < ID > variableDeclaratorId1()
  | objectDeclaratorId()
}


void objectDeclaratorId() :
{}
{
    LOOKAHEAD(3) < MINOR > <ID> < MAJOR > variableDeclaratorId1() < ID >
    | < MINOR > <ID> <COMMA > <ID> < MAJOR > variableDeclaratorId1() < ID >
}

void variableDeclaratorId1() :
{}
{
  < PARQA > < PARQC > variableDeclaratorId() | {}
}

void variableInitializer() :
{}
{
  arrayInitializer() | expression()
}

void methodDeclaration() :
{}
{
  methodHeader() methodBody()
}

void methodHeader() :
{}
{
  (methodModifiers())? resultType() methodDeclarator() (throwsConstruct())?
}

void resultType() :
{}
{
  < VOID > | type()
}

void methodModifiers() :
{}
{
  methodModifier() methodModifiers1()
}

void methodModifiers1() :
{}
{
  methodModifier() methodModifiers1() | {}
}

void methodModifier() :
{}
{
  < PUBLIC > | < PROTECTED > | < PRIVATE > | < STATIC > | < ABSTRACT > | < FINAL > | < SYNCHRONIZED > | < NATIVE >
}

void methodDeclarator() :
{}
{
  < ID > < PARTA > (formalParameterList())? < PARTC >
}

void methodBody() :
{}
{
  block() | < SEMIC >
}

void interfaceDeclaration() :
{}
{
  (interfaceModifiers())? < INTERFACE > < ID > (extendsInterfaces())? interfaceBody()
}

void interfaceModifiers() :
{}
{
  interfaceModifier() interfaceModifiers1()
}

void interfaceModifiers1() :
{}
{
  interfaceModifier() interfaceModifiers() | {}
}

void interfaceModifier() :
{}
{
  < PUBLIC > | < ABSTRACT >
}

void extendsInterfaces() :
{}
{
  < EXTENDS > classOrInterfaceType() extendsInterfaces1()
}

void extendsInterfaces1() :
{}
{
  < COMMA > classOrInterfaceType() extendsInterfaces1() | {}
}

void interfaceBody() :
{}
{
  < PARGA > (interfaceMemberDeclarations())? < PARGC >
}

void interfaceMemberDeclarations() :
{}
{
  interfaceMemberDeclaration() interfaceMemberDeclarations1()
}

void interfaceMemberDeclarations1() :
{}
{
  interfaceMemberDeclaration() interfaceMemberDeclarations1() | {}
}

void interfaceMemberDeclaration() :
{}
{
   LOOKAHEAD(3) constantDeclaration() | abstractMethodDeclaration()
}

void constantDeclaration() :
{}
{
  constantModifiers() type() variableDeclarator()
}

void constantModifiers() :
{}
{
  < PUBLIC > | < STATIC > | < FINAL >
}

void abstractMethodDeclaration() :
{}
{
  (abstractMethodModifiers())? resultType() methodDeclarator() (throwsConstruct())? < SEMIC >
}

void abstractMethodModifiers() :
{}
{
  abstractMethodModifier() abstractMethodModifiers1()
}

void abstractMethodModifiers1() :
{}
{
  abstractMethodModifier() abstractMethodModifiers1() | {}
}

void abstractMethodModifier() :
{}
{
  < PUBLIC > | < ABSTRACT >
}

void arrayInitializer() :
{}
{
  < PARGA > variableInitializers() (< COMMA >)? < PARGC >
}

void variableInitializers() :
{}
{
  variableInitializer() variableInitializers1()
}

void variableInitializers1() :
{}
{
  < COMMA > variableInitializer() variableInitializers1() | {}
}

void type() :
{}
{
	(primitiveType() | classOrInterfaceType()) type1()
}

void type1():
{}
{
	< PARQA > < PARQC > type1() | { }
}

void primitiveType() :
{}
{
 < BYTE > | < SHORT > | < INT > | < LONG > | < CHAR > | < BOOLEAN > | floatingPointType()
}

void numericType():
{}
{
  < BYTE > | < SHORT > | < INT > | < LONG > | < CHAR > | floatingPointType()
}


void floatingPointType():
{}
{
  < FLOAT > | < DOUBLE >
}

void referenceType():
{}
{
   LOOKAHEAD(3) classOrInterfaceType() | type() < PARQA > < PARQC >
}

void classOrInterfaceType():
{}
{
   /*LOOKAHEAD(3) classType() | interfaceType()*/
   LOOKAHEAD(4) <ID> <MINOR> <ID> <MAJOR>
   | LOOKAHEAD(2) <ID> <MINOR> <ID> <COMMA> <ID> <MAJOR>
   | <ID>
}

/*
void classType():
{}
{
  typeName()
}

void interfaceType():
{}
{
  typeName()
}*/

void block():
{}
{
  < PARGA > (blockStatements())? < PARGC >
}


void blockStatements():
{}
{
  blockStatement() blockStatements1()
}

void blockStatements1():
{}
{
	blockStatement() blockStatements1() | { }
}

void blockStatement():
{}
{
	 LOOKAHEAD(3) {System.out.println("localVariableDeclarationStatement");} localVariableDeclarationStatement()
	 | {System.out.println("statement");} statement()
}

void localVariableDeclarationStatement():
{}
{
	localVariableDeclaration() <SEMIC>
}

void localVariableDeclaration():
{}
{
	type() variableDeclarators()
}


void statement():
{}
{
	 LOOKAHEAD(2) {System.out.println("statementWithoutTrailingSubstatement");} statementWithoutTrailingSubstatement()
	| labeledStatement()
	| ifThenStatement()
	| whileStatement()
	| forStatement()
}

void statementNoShortIf():
{}
{
	 LOOKAHEAD(2) statementWithoutTrailingSubstatement()
	| labeledStatementNoShortIf()
	| ifThenElseStatementNoShortIf()
	| whileStatementNoShortIf()
	| forStatementNoShortIf()
}

void statementWithoutTrailingSubstatement():
{}
{
	block()
	| emptyStatement()
	| {System.out.println("expressionStatement");} expressionStatement()
	| switchStatement()
	| doStatement()
	| breakStatement()
	| continueStatement()
	| returnStatement()
	| synchronizedStatement()
	| throwsStatement()
	| tryStatement()
}

void emptyStatement():
{}
{
	< SEMIC >
}

void labeledStatement():
{}
{
	< ID > <DPOINTS > statement()
}

void labeledStatementNoShortIf():
{}
{
	< ID > <DPOINTS > statementNoShortIf()
}

void expressionStatement():
{}
{
	statementExpression() < SEMIC >
}

void statementExpression():
{}
{
	LOOKAHEAD(6) {System.out.println("assignment");} assignment()
	| LOOKAHEAD(4) {System.out.println("methodInvocation");} methodInvocation()
	| {System.out.println("postIncrDecrExpression");} postIncrDecrExpression()
	| {System.out.println("preIncrDecrExpression");} preIncrDecrExpression()
	| {System.out.println("assignmenclassInstanceCreationExpression");} classInstanceCreationExpression()
}

void ifThenStatement():
{}
{
	{System.out.println("IF");}
	< IF > < PARTA > expression() < PARTC > statement() elseStmt()
}

void elseStmt():
{}
{
	< ELSE > statement() | {}
}

void ifThenElseStatementNoShortIf():
{}
{
	< IF > < PARTA > expression() < PARTC > statementNoShortIf() < ELSE > statementNoShortIf()
}

void switchStatement():
{}
{
	< SWITCH > < PARTA > expression() < PARTC > switchBlock()
}

void switchBlock():
{}
{
	/*< PARGA > (switchBlockStatementGroups())? (switchLabels())? < PARGC >*/
	LOOKAHEAD(2) < PARGA > < PARGC >
	| LOOKAHEAD(2) < PARGA > switchBlockStatementGroups() < PARGC >
	| LOOKAHEAD(2) < PARGA > switchLabels() < PARGC >
	| < PARGA > switchBlockStatementGroups() switchLabels() < PARGC >
}

void switchBlockStatementGroups():
{}
{
	switchBlockStatementGroup() switchBlockStatementGroups1()
}

void switchBlockStatementGroups1():
{}
{
	switchBlockStatementGroup() switchBlockStatementGroups1() | { }
}

void switchBlockStatementGroup():
{}
{
	switchLabels() blockStatements()
}

void switchLabels():
{}
{
	switchLabel() switchLabels1()
}

void switchLabels1():
{}
{
	switchLabel() switchLabels1() | { }
}

void switchLabel():
{}
{
  < CASE > constantExpression() < DPOINTS >
|  < _DEFAULT > < DPOINTS >
}

void whileStatement():
{}
{
  < WHILE > <PARTA > expression() < PARTC > statement()
}

void whileStatementNoShortIf():
{}
{
  < WHILE > <PARTA > expression() < PARTC > statementNoShortIf()
}


void doStatement():
{}
{
  < DO > statement() < WHILE > <PARTA > expression() < PARTC > < SEMIC >
}

void forStatement():
{}
{
  LOOKAHEAD(5) < FOR > < PARTA > forInit() < SEMIC > expression()  < SEMIC > forUpdate() < PARTC > statement()
  | < FOR > < PARTA > type() < ID > < DPOINTS > expression() < PARTC > statement()
}

void forStatementNoShortIf():
{}
{
  < FOR > <PARTA > forInit() < SEMIC > expression()  < SEMIC > forUpdate() < PARTC > statementNoShortIf()
}

void forInit():
{}
{
  	 LOOKAHEAD(3) statementExpressionList()
	| localVariableDeclaration()
}

void forUpdate():
{}
{
  	statementExpressionList()
}

void statementExpressionList():
{}
{
  	statementExpression() statementExpressionList1()
}

void statementExpressionList1():
{}
{
	< COMMA > statementExpression() statementExpressionList1() | { }
}

void breakStatement():
{}
{
  < BREAK > (< ID >)? < SEMIC >
}

void continueStatement():
{}
{
  < CONTINUE > (< ID >)? < SEMIC >
}
void returnStatement():
{}
{
  < RETURN > expression() < SEMIC >
}

void throwsStatement():
{}
{
  < THROW > expression() < SEMIC >
}

void synchronizedStatement():
{}
{
  < SYNCHRONIZED > < PARTA > expression() < PARTC > block()
}

void tryStatement():
{}
{
  	 LOOKAHEAD(3) < TRY > block() catches()
	| < TRY > block() (catches())? finallys()
}

void catches():
{}
{
  	catchClause() catches1()
}

void catches1():
{}
{
	catchClause() catches1() | { }
}

void catchClause():
{}
{
  	< CATCH > <PARTA> formalParameter() < PARTC > block()
}

void finallys():
{}
{
	< FINALLY > block()
}

void constantExpression() :
{}
{
	expression()
}

void expression() :
{}
{
	assignmentExpression()
}

void assignmentExpression() :
{}
{
	LOOKAHEAD(3) conditionalExpression() | assignment()
}

void assignment() :
{}
{
	{System.out.println("ASSIGNMENT");}
	leftHandSide() assignmentOperator() assignmentExpression()
}

void leftHandSide() :
{}
{
	LOOKAHEAD(3) {System.out.println("leftHand fieldAcc");} fieldAccess()
	| LOOKAHEAD(3) {System.out.println("leftHand expr");} expressionName()
	| arrayAccess()
}

void assignmentOperator() :
{}
{
	< MULASS > | < DIVASS > | < ADDASS > | < SUBASS > | <ASS>
}

void conditionalExpression() :
{}
{
	 LOOKAHEAD(3) conditionalOrExpression() | conditionalOrExpression() <QMARK> expression() <DPOINTS> conditionalExpression()
}

void conditionalOrExpression() :
{}
{
	conditionalAndExpression() conditionalOrExpression1()
}

void conditionalOrExpression1():
{}
{
  <OR> conditionalAndExpression() conditionalOrExpression1() | { }
}

void conditionalAndExpression() :
{}
{
	inclusiveOrExpression() conditionalAndExpression1()
}

void conditionalAndExpression1():
{}
{
	<AND> inclusiveOrExpression() conditionalAndExpression1() | { }
}

void inclusiveOrExpression() :
{}
{
	exclusiveOrExpression() inclusiveOrExpression1()
}

void inclusiveOrExpression1():
{}
{
	<OR> exclusiveOrExpression() inclusiveOrExpression1() | { }
}


void exclusiveOrExpression() :
{}
{
	andExpression() exclusiveOrExpression1()
}

void exclusiveOrExpression1() :
{}
{
	<EXP> andExpression() exclusiveOrExpression1() | { }
}

void andExpression() :
{}
{
	equalityExpression() andExpression1()
}

void andExpression1():
{}
{
  <AND> equalityExpression() andExpression1() | { }
}

void equalityExpression() :
{}
{
	relationalExpression() equalityExpression1()
}

void equalityExpression1():
{}
{
  (<MAJOR> | <MINOR> | <RELOP>) relationalExpression() equalityExpression1() | { }
}

void relationalExpression() :
{}
{
	additiveExpression() relationalExpression1()
}

void relationalExpression1() :
{}
{
	<MAJOR> additiveExpression() relationalExpression1()
	| <MINOR> additiveExpression() relationalExpression1()
	| <RELOP> additiveExpression() relationalExpression1()
	| <INSTANCEOF> referenceType() relationalExpression1()
	| {}
}

void additiveExpression() :
{}
{
	multiplicativeExpression() additiveExpression1()
}

void additiveExpression1():
{}
{
  <ARITOP_LP> multiplicativeExpression() additiveExpression1() | { }
}

void multiplicativeExpression() :
{}
{
	unaryExpression()  multiplicativeExpression1()
}

void multiplicativeExpression1():
{}
{
  <ARITOP_HP> unaryExpression() multiplicativeExpression1() | { }
}

void castExpression() :
{}
{
	{System.out.println("CAST");}
	<PARTA> type() <PARTC> unaryExpression() /*| <PARTA> referenceType() <PARTC> unaryExpression()*/
}

void unaryExpression() :
{}
{
	 LOOKAHEAD(8) expressionName() <PARTA> (argumentList())? <PARTC> (< DOT > unaryExpression())?
	 | LOOKAHEAD(5) <ID> <DOT> <CLASS>
	 | LOOKAHEAD(3) castExpression()
	 | LOOKAHEAD(3) primary()
	 | LOOKAHEAD(3) expressionName()
	 | LOOKAHEAD(3) preIncrDecrExpression()
	 | LOOKAHEAD(3) < ARITOP_LP > unaryExpression()
	 | < NOT > unaryExpression()
}

void preIncrDecrExpression() :
{}
{
	<ARITOP_LP> <ARITOP_LP> unaryExpression()
}

void postIncrDecrExpression() :
{}
{
	expressionName() <ARITOP_LP> <ARITOP_LP>
}

void methodInvocation() :
{}
{
	 LOOKAHEAD(3) {System.out.println("MethodName e ArgumentL");} methodName() <PARTA> (argumentList())? <PARTC> methodInvocation1()
	 | LOOKAHEAD(3) {System.out.println("KKK");} primary() <PARTA> (argumentList())? <PARTC> methodInvocation1()
	 | <THIS> <DOT> ambiguousName() <PARTA> (argumentList())? <PARTC> methodInvocation1()
	 | <SUPER> <DOT> <ID> <PARTA> (argumentList())? <PARTC> methodInvocation1()
}

void methodInvocation1():
{}
{
	{System.out.println("Meth Inv 1");}
	<DOT> methodInvocation()
	| {System.out.println("Meth Inv 1 EPS");} {}
}


void fieldAccess() :
{}
{
	< THIS > < DOT > < ID > | < SUPER > < DOT > < ID >
}

void primary() :
{}
{
	LOOKAHEAD(3) primaryNoNewArray() | arrayCreationExpression()
}

void primaryNoNewArray() :
{}
{
	LOOKAHEAD(2) arrayAccess()
	/*| LOOKAHEAD(2) {System.out.println("okok");} < THIS > <DOT> expressionName() TODO???*/
	| < THIS >
	| <PARTA> expression() <PARTC>
	| classInstanceCreationExpression() /* | fieldAccess() | methodInvocation() */
	| literal()
}

void classInstanceCreationExpression() :
{}
{
	LOOKAHEAD(3) <NEW> classOrInterfaceType() <PARTA> (argumentList())? <PARTC>
	| <NEW> classOrInterfaceType() <MINOR> (argumentList())? <MAJOR> <PARTA> (argumentList())? <PARTC>
}

void argumentList() :
{}
{
	expression() argumentList1()
}


void argumentList1() :
{}
{
  <COMMA> expression() argumentList1()  | {}
}


void arrayCreationExpression() :
{}
{
	LOOKAHEAD(2) <NEW> primitiveType() dimExprs() (dims())? | <NEW> classOrInterfaceType() dimExprs() (dims())?
}

void dimExprs() :
{}
{
	dimExpr() dimExprs1()
}


void dimExprs1() :
{}
{
	dimExpr()dimExprs1() | {}
}


void dimExpr() :
{}
{
	<PARQA> expression() <PARQC>
}

void dims() :
{}
{
	dims1() <PARQA> <PARQC>
}


void dims1() :
{}
{

   <PARQA> <PARQC> dims1() | {}

}


void arrayAccess() :
{}
{
	expressionName() <PARQA> expression() <PARQC> // | primaryNoNewArray() <PARQA> expression() <PARQC>
}

void typeName():
{}
{
   <ID> typeName1()
}

void typeName1():
{}
{
  <COMMA> <ID> typeName1() | {}
}


void simpleTypeName():
{}
{
   <ID>
}

void expressionName():
{}
{
	ambiguousName()
}

void methodName():
{}
{
	ambiguousName()
} 

void ambiguousName():
{}
{
	< ID > ambiguousName1()
}


void ambiguousName1():
{}
{
	< DOT > < ID > ambiguousName1() | {}
}


void literal():
{}
{
	(< TRUE > | < FALSE >)
	| <CHARVALUE>
	| <LITERAL>
	| < NUM >
	| < NULL >
}
